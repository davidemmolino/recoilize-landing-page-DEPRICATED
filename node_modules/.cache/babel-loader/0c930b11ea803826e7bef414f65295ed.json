{"ast":null,"code":"// node parameter should be root of the fiber node tree, can be grapped with startNode from below\n// const startNode = document.getElementById('root')._reactRootContainer._internalRoot.current;\nconst formatFiberNodes = node => {\n  const formattedNode = {\n    // this function grabs a 'name' based on the tag of the node\n    name: assignName(node),\n    tag: node.tag,\n    children: [],\n    recoilNodes: createAtomsSelectorArray(node),\n    actualDuration: node.actualDuration\n  }; // loop through and recursively call all nodes to format their 'sibling' and 'child' properties to our desired tree shape\n\n  let currentNode = node.child;\n\n  while (currentNode) {\n    formattedNode.children.push(formatFiberNodes(currentNode));\n    currentNode = currentNode.sibling;\n  }\n\n  return formattedNode;\n};\n\nconst createAtomsSelectorArray = node => {\n  // initialize empty array for all atoms and selectors.  Elements will be all atom and selector names, as strings\n  const recoilNodes = []; // function that returns boolean with whether 'node' contains atoms or selectors\n\n  if (checkForAtoms(node)) {\n    let current = node.memoizedState; // loop through all memoizedStates in currentNode\n\n    while (current) {\n      // this is based on the way recoil atoms and selectors are showing in the window.  Currently best way to grab all names of atoms and selectors\n      if (current.memoizedState && Array.isArray(current.memoizedState) && typeof current.memoizedState[0] === \"function\" && current.memoizedState[1].length === 2) {\n        // current.memoizedState[1][1].current is a Map that contains the a key, the key is the name of every atom/selector in that fiber node, that key is a string\n        // sean\n        if (current.memoizedState[1][1] && current.memoizedState[1][1].current) {\n          for (let [key, value] of current.memoizedState[1][1].current) {\n            recoilNodes.push(key);\n          }\n        }\n      }\n\n      current = current.next;\n    }\n  }\n\n  return recoilNodes;\n};\n\nconst checkForAtoms = node => {\n  if (node.memoizedState && node.memoizedState.next && node.memoizedState.next.memoizedState && node.memoizedState.next.memoizedState.current) {\n    return true;\n  }\n\n  return false;\n}; // keep an eye on this section as we test bigger and bigger applications SEAN\n\n\nconst assignName = node => {\n  // Find name of a class component\n  if (node.type && node.type.name) return node.type.name; // Tag 5 === HostComponent\n\n  if (node.tag === 5) return `${node.type}`; // Tag 3 === HostRoot\n\n  if (node.tag === 3) return \"HR\"; // Tag 3 === HostText\n\n  if (node.tag === 6) {\n    return node.memoizedProps;\n  }\n\n  if (node.tag === 7) return \"Fragment\";\n};\n\nmodule.exports = {\n  formatFiberNodes\n}; // if testing this function on the browser, use line below to log the formatted tree in the console\n//let formattedFiberNodes = formatFiberNodes(document.getElementById('root')._reactRootContainer._internalRoot.current)","map":{"version":3,"sources":["/home/davide/Desktop/recoilize-landing-page/node_modules/recoilize/formatFiberNodes.js"],"names":["formatFiberNodes","node","formattedNode","name","assignName","tag","children","recoilNodes","createAtomsSelectorArray","actualDuration","currentNode","child","push","sibling","checkForAtoms","current","memoizedState","Array","isArray","length","key","value","next","type","memoizedProps","module","exports"],"mappings":"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","sourcesContent":["// node parameter should be root of the fiber node tree, can be grapped with startNode from below\n// const startNode = document.getElementById('root')._reactRootContainer._internalRoot.current;\nconst formatFiberNodes = (node) => {\n  const formattedNode = {\n    // this function grabs a 'name' based on the tag of the node\n    name: assignName(node),\n    tag: node.tag,\n    children: [],\n    recoilNodes: createAtomsSelectorArray(node),\n    actualDuration: node.actualDuration,\n  };\n  // loop through and recursively call all nodes to format their 'sibling' and 'child' properties to our desired tree shape\n  let currentNode = node.child;\n  while (currentNode) {\n    formattedNode.children.push(formatFiberNodes(currentNode));\n    currentNode = currentNode.sibling;\n  }\n  return formattedNode;\n};\nconst createAtomsSelectorArray = (node) => {\n  // initialize empty array for all atoms and selectors.  Elements will be all atom and selector names, as strings\n  const recoilNodes = [];\n  // function that returns boolean with whether 'node' contains atoms or selectors\n  if (checkForAtoms(node)) {\n    let current = node.memoizedState;\n    // loop through all memoizedStates in currentNode\n    while (current) {\n      // this is based on the way recoil atoms and selectors are showing in the window.  Currently best way to grab all names of atoms and selectors\n      if (\n        current.memoizedState &&\n        Array.isArray(current.memoizedState) &&\n        typeof current.memoizedState[0] === \"function\" &&\n        current.memoizedState[1].length === 2\n      ) {\n        // current.memoizedState[1][1].current is a Map that contains the a key, the key is the name of every atom/selector in that fiber node, that key is a string\n        // sean\n        if (\n          current.memoizedState[1][1] &&\n          current.memoizedState[1][1].current\n        ) {\n          for (let [key, value] of current.memoizedState[1][1].current) {\n            recoilNodes.push(key);\n          }\n        }\n      }\n      current = current.next;\n    }\n  }\n  return recoilNodes;\n};\nconst checkForAtoms = (node) => {\n  if (\n    node.memoizedState &&\n    node.memoizedState.next &&\n    node.memoizedState.next.memoizedState &&\n    node.memoizedState.next.memoizedState.current\n  ) {\n    return true;\n  }\n  return false;\n};\n// keep an eye on this section as we test bigger and bigger applications SEAN\nconst assignName = (node) => {\n  // Find name of a class component\n  if (node.type && node.type.name) return node.type.name;\n  // Tag 5 === HostComponent\n  if (node.tag === 5) return `${node.type}`;\n  // Tag 3 === HostRoot\n  if (node.tag === 3) return \"HR\";\n  // Tag 3 === HostText\n  if (node.tag === 6) {\n    return node.memoizedProps;\n  }\n  if (node.tag === 7) return \"Fragment\";\n};\nmodule.exports = { formatFiberNodes };\n// if testing this function on the browser, use line below to log the formatted tree in the console\n//let formattedFiberNodes = formatFiberNodes(document.getElementById('root')._reactRootContainer._internalRoot.current)\n"]},"metadata":{},"sourceType":"script"}