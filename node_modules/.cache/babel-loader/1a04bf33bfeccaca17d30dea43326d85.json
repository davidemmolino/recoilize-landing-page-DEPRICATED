{"ast":null,"code":"import React, { useState, useEffect } from \"react\";\nimport { useRecoilTransactionObserver_UNSTABLE, useRecoilSnapshot, useGotoRecoilSnapshot } from \"recoil\";\nimport { formatFiberNodes } from \"./formatFiberNodes\"; // grabs isPersistedState from sessionStorage\n\nlet isPersistedState = sessionStorage.getItem(\"isPersistedState\"); // isRestored state disables snapshots from being recorded\n\nlet isRestoredState = false; // set default throttle to 70, throttle timer changes with every snapshot\n\nlet throttleTimer = 0;\nlet throttleLimit = 70;\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n  const {\n    root\n  } = props;\n  let nodes = null;\n\n  if (typeof props.nodes === \"object\" && !Array.isArray(props.nodes)) {\n    nodes = Object.values(props.nodes);\n  } else if (Array.isArray(props.nodes)) {\n    nodes = props.nodes;\n  }\n\n  const snapshot = useRecoilSnapshot(); // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n\n  const [snapshots, setSnapshots] = useState([snapshot]); // const [isRestoredState, setRestoredState] = useState(false);\n\n  const gotoSnapshot = useGotoRecoilSnapshot();\n  const filteredSnapshot = {};\n\n  const currentTree = snapshot._store.getState().currentTree; // Traverse all atoms and selector state nodes and get value\n\n\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents;\n    const nodeDeps = currentTree.nodeDeps.get(node.key);\n    const nodeToNodeSubscriptions = currentTree.nodeToNodeSubscriptions.get(node.key); // Construct node data structure for dev tool to consume\n\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps ? Array.from(nodeDeps) : [],\n      nodeToNodeSubscriptions: nodeToNodeSubscriptions ? Array.from(nodeToNodeSubscriptions) : []\n    };\n  }); // React lifecycle hook on re-render\n\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener(\"message\", onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot); // Post message to content script on every re-render of the developers application only if content script has started\n\n      sendWindowMessage(\"recordSnapshot\", devToolData);\n    } else {\n      isRestoredState = false;\n    } // Clears the window event listener.\n\n\n    return () => window.removeEventListener(\"message\", onMessageReceived);\n  }); // Listener callback for messages sent to windowf\n\n  const onMessageReceived = msg => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case \"contentScriptStarted\":\n        if (isPersistedState === \"false\" || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(filteredSnapshot);\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot);\n          sendWindowMessage(\"moduleInitialized\", devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage(\"persistSnapshots\", null);\n        }\n\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n\n      case \"snapshotTimeTravel\":\n        timeTravelToSnapshot(msg);\n        break;\n\n      case \"persistState\":\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n\n      case \"throttleEdit\":\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n\n      default:\n        break;\n    }\n  }; // assigns or switches isPersistedState in sessionStorage\n\n\n  const switchPersistMode = () => {\n    if (isPersistedState === \"false\" || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem(\"isPersistedState\", true); // stores the length of current list of snapshots in sessionStorage\n\n      sessionStorage.setItem(\"persistedSnapshots\", snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem(\"isPersistedState\", false);\n    }\n  }; // function retreives length and fills snapshot array\n\n\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem(\"persistedSnapshots\");\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  }; // Sends window an action and payload message.\n\n\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage({\n      action,\n      payload\n    }, \"*\");\n  };\n\n  const createDevToolDataObject = filteredSnapshot => {\n    return {\n      filteredSnapshot: filteredSnapshot,\n      componentAtomTree: formatFiberNodes(root._reactRootContainer._internalRoot.current)\n    };\n  };\n\n  const formatAtomSelectorRelationship = filteredSnapshot => {\n    if (window.$recoilDebugStates && Array.isArray(window.$recoilDebugStates) && window.$recoilDebugStates.length) {\n      let snapObj = window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n\n      if (snapObj.hasOwnProperty(\"nodeDeps\")) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n\n      if (snapObj.hasOwnProperty(\"nodeToNodeSubscriptions\")) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n\n    return filteredSnapshot;\n  }; // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n\n\n  const timeTravelToSnapshot = async msg => {\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  }; // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n\n\n  useRecoilTransactionObserver_UNSTABLE(({\n    snapshot\n  }) => {\n    const now = new Date().getTime();\n\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n  return null;\n}","map":{"version":3,"sources":["/home/davide/Desktop/recoilize-landing-page/node_modules/recoilize/index.js"],"names":["React","useState","useEffect","useRecoilTransactionObserver_UNSTABLE","useRecoilSnapshot","useGotoRecoilSnapshot","formatFiberNodes","isPersistedState","sessionStorage","getItem","isRestoredState","throttleTimer","throttleLimit","RecoilizeDebugger","props","root","nodes","Array","isArray","Object","values","snapshot","snapshots","setSnapshots","gotoSnapshot","filteredSnapshot","currentTree","_store","getState","forEach","node","index","type","__proto__","constructor","name","contents","getLoadable","nodeDeps","get","key","nodeToNodeSubscriptions","from","window","addEventListener","onMessageReceived","devToolData","createDevToolDataObject","sendWindowMessage","removeEventListener","msg","data","action","initialFilteredSnapshot","formatAtomSelectorRelationship","setProperIndexForPersistedState","timeTravelToSnapshot","switchPersistMode","parseInt","payload","value","setItem","length","retreived","snapshotsArray","Number","fill","postMessage","componentAtomTree","_reactRootContainer","_internalRoot","current","$recoilDebugStates","snapObj","hasOwnProperty","snapshotIndex","now","Date","getTime"],"mappings":"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","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport {\n  useRecoilTransactionObserver_UNSTABLE,\n  useRecoilSnapshot,\n  useGotoRecoilSnapshot,\n} from \"recoil\";\nimport { formatFiberNodes } from \"./formatFiberNodes\";\n\n// grabs isPersistedState from sessionStorage\nlet isPersistedState = sessionStorage.getItem(\"isPersistedState\");\n\n// isRestored state disables snapshots from being recorded\nlet isRestoredState = false;\n\n// set default throttle to 70, throttle timer changes with every snapshot\nlet throttleTimer = 0;\nlet throttleLimit = 70;\n\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n\n  const { root } = props;\n\n  let nodes = null;\n\n  if (typeof props.nodes === \"object\" && !Array.isArray(props.nodes)) {\n    nodes = Object.values(props.nodes);\n  } else if (Array.isArray(props.nodes)) {\n    nodes = props.nodes;\n  }\n\n  const snapshot = useRecoilSnapshot();\n  // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n  const [snapshots, setSnapshots] = useState([snapshot]);\n  // const [isRestoredState, setRestoredState] = useState(false);\n  const gotoSnapshot = useGotoRecoilSnapshot();\n\n  const filteredSnapshot = {};\n  const currentTree = snapshot._store.getState().currentTree;\n\n  // Traverse all atoms and selector state nodes and get value\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents;\n    const nodeDeps = currentTree.nodeDeps.get(node.key);\n    const nodeToNodeSubscriptions = currentTree.nodeToNodeSubscriptions.get(\n      node.key\n    );\n\n    // Construct node data structure for dev tool to consume\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps ? Array.from(nodeDeps) : [],\n      nodeToNodeSubscriptions: nodeToNodeSubscriptions\n        ? Array.from(nodeToNodeSubscriptions)\n        : [],\n    };\n  });\n\n  // React lifecycle hook on re-render\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener(\"message\", onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot);\n      // Post message to content script on every re-render of the developers application only if content script has started\n      sendWindowMessage(\"recordSnapshot\", devToolData);\n    } else {\n      isRestoredState = false;\n    }\n\n    // Clears the window event listener.\n    return () => window.removeEventListener(\"message\", onMessageReceived);\n  });\n\n  // Listener callback for messages sent to windowf\n  const onMessageReceived = (msg) => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case \"contentScriptStarted\":\n        if (isPersistedState === \"false\" || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(\n            filteredSnapshot\n          );\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot);\n          sendWindowMessage(\"moduleInitialized\", devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage(\"persistSnapshots\", null);\n        }\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n      case \"snapshotTimeTravel\":\n        timeTravelToSnapshot(msg);\n        break;\n      case \"persistState\":\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n      case \"throttleEdit\":\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  // assigns or switches isPersistedState in sessionStorage\n  const switchPersistMode = () => {\n    if (isPersistedState === \"false\" || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem(\"isPersistedState\", true);\n\n      // stores the length of current list of snapshots in sessionStorage\n      sessionStorage.setItem(\"persistedSnapshots\", snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem(\"isPersistedState\", false);\n    }\n  };\n\n  // function retreives length and fills snapshot array\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem(\"persistedSnapshots\");\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  };\n\n  // Sends window an action and payload message.\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage(\n      {\n        action,\n        payload,\n      },\n      \"*\"\n    );\n  };\n\n  const createDevToolDataObject = (filteredSnapshot) => {\n    return {\n      filteredSnapshot: filteredSnapshot,\n      componentAtomTree: formatFiberNodes(\n        root._reactRootContainer._internalRoot.current\n      ),\n    };\n  };\n\n  const formatAtomSelectorRelationship = (filteredSnapshot) => {\n    if (\n      window.$recoilDebugStates &&\n      Array.isArray(window.$recoilDebugStates) &&\n      window.$recoilDebugStates.length\n    ) {\n      let snapObj =\n        window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n      if (snapObj.hasOwnProperty(\"nodeDeps\")) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n      if (snapObj.hasOwnProperty(\"nodeToNodeSubscriptions\")) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n    return filteredSnapshot;\n  };\n\n  // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n  const timeTravelToSnapshot = async (msg) => {\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  };\n\n  // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n  useRecoilTransactionObserver_UNSTABLE(({ snapshot }) => {\n    const now = new Date().getTime();\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n\n  return null;\n}\n"]},"metadata":{},"sourceType":"module"}