{"ast":null,"code":"import React, { useState, useEffect } from 'react';\nimport { useRecoilTransactionObserver_UNSTABLE, useRecoilSnapshot, useGotoRecoilSnapshot } from 'recoil';\nimport { formatFiberNodes } from './formatFiberNodes'; // grabs isPersistedState from sessionStorage\n\nlet isPersistedState = sessionStorage.getItem('isPersistedState'); // isRestored state disables snapshots from being recorded\n\nlet isRestoredState = false; // set default throttle to 70, throttle timer changes with every snapshot\n\nlet throttleTimer = 0;\nlet throttleLimit = 70; // persistedSnapshots initially null\n// let persistedSnapshots = null;\n\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n  // Check if a root was passed to props.\n  if (props.root) {\n    const {\n      root\n    } = props;\n  } else {\n    const root = document.getElementById('root');\n  }\n\n  const snapshot = useRecoilSnapshot(); // getNodes_UNSTABLE will return an iterable that contains atom and selector objects.\n\n  const nodes = [...snapshot.getNodes_UNSTABLE()]; // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n\n  const [snapshots, setSnapshots] = useState([snapshot]); // const [isRestoredState, setRestoredState] = useState(false);\n\n  const gotoSnapshot = useGotoRecoilSnapshot();\n  const filteredSnapshot = {};\n  /*\n  A nodeDeps object is constructed using getDeps_UNSTABLE. \n  This object will then be used to construct a nodeSubscriptions object. \n  After continuous testing, getSubscriptions_UNSTABLE was deemed too unreliable. \n  */\n\n  const nodeDeps = {};\n  const nodeSubscriptions = {};\n  nodes.forEach(node => {\n    const getDeps = [...snapshot.getDeps_UNSTABLE(node)];\n    nodeDeps[node.key] = getDeps.map(dep => dep.key);\n  });\n\n  for (let key in nodeDeps) {\n    nodeDeps[key].forEach(node => {\n      if (nodeSubscriptions[node]) {\n        nodeSubscriptions[node].push(key);\n      } else {\n        nodeSubscriptions[node] = [key];\n      }\n    });\n  }\n\n  ; // Traverse all atoms and selector state nodes and get value\n\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents; // Construct node data structure for dev tool to consume\n\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps[node.key],\n      nodeToNodeSubscriptions: nodeSubscriptions[node.key] ? nodeSubscriptions[node.key] : []\n    };\n  }); // React lifecycle hook on re-render\n\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener('message', onMessageReceived);\n\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot); // Post message to content script on every re-render of the developers application only if content script has started\n\n      sendWindowMessage('recordSnapshot', devToolData);\n    } else {\n      isRestoredState = false;\n    } // Clears the window event listener.\n\n\n    return () => window.removeEventListener('message', onMessageReceived);\n  }); // Listener callback for messages sent to windowf\n\n  const onMessageReceived = msg => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case 'contentScriptStarted':\n        if (isPersistedState === 'false' || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(filteredSnapshot);\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot);\n          sendWindowMessage('moduleInitialized', devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage('persistSnapshots', null);\n        }\n\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n\n      case 'snapshotTimeTravel':\n        timeTravelToSnapshot(msg);\n        break;\n\n      case 'persistState':\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n\n      case 'throttleEdit':\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n\n      default:\n        break;\n    }\n  }; // assigns or switches isPersistedState in sessionStorage\n\n\n  const switchPersistMode = () => {\n    if (isPersistedState === 'false' || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem('isPersistedState', true); // stores the length of current list of snapshots in sessionStorage\n\n      sessionStorage.setItem('persistedSnapshots', snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem('isPersistedState', false);\n    }\n  }; // function retreives length and fills snapshot array\n\n\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem('persistedSnapshots');\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  }; // Sends window an action and payload message.\n\n\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage({\n      action,\n      payload\n    }, '*');\n  };\n\n  const createDevToolDataObject = filteredSnapshot => {\n    return {\n      filteredSnapshot: filteredSnapshot,\n      componentAtomTree: formatFiberNodes(root._reactRootContainer._internalRoot.current)\n    };\n  };\n\n  const formatAtomSelectorRelationship = filteredSnapshot => {\n    if (window.$recoilDebugStates && Array.isArray(window.$recoilDebugStates) && window.$recoilDebugStates.length) {\n      let snapObj = window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n\n      if (snapObj.hasOwnProperty('nodeDeps')) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n\n      if (snapObj.hasOwnProperty('nodeToNodeSubscriptions')) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n\n    return filteredSnapshot;\n  }; // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n\n\n  const timeTravelToSnapshot = async msg => {\n    // await setRestoredState(true);\n    // await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n    // await setRestoredState(false);\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  }; // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n\n\n  useRecoilTransactionObserver_UNSTABLE(({\n    snapshot\n  }) => {\n    const now = new Date().getTime();\n\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n  return null;\n}","map":{"version":3,"sources":["/home/davide/Desktop/recoilize-landing-page/node_modules/recoilize/index.js"],"names":["React","useState","useEffect","useRecoilTransactionObserver_UNSTABLE","useRecoilSnapshot","useGotoRecoilSnapshot","formatFiberNodes","isPersistedState","sessionStorage","getItem","isRestoredState","throttleTimer","throttleLimit","RecoilizeDebugger","props","root","document","getElementById","snapshot","nodes","getNodes_UNSTABLE","snapshots","setSnapshots","gotoSnapshot","filteredSnapshot","nodeDeps","nodeSubscriptions","forEach","node","getDeps","getDeps_UNSTABLE","key","map","dep","push","index","type","__proto__","constructor","name","contents","getLoadable","nodeToNodeSubscriptions","window","addEventListener","onMessageReceived","devToolData","createDevToolDataObject","sendWindowMessage","removeEventListener","msg","data","action","initialFilteredSnapshot","formatAtomSelectorRelationship","setProperIndexForPersistedState","timeTravelToSnapshot","switchPersistMode","parseInt","payload","value","setItem","length","retreived","snapshotsArray","Array","Number","fill","postMessage","componentAtomTree","_reactRootContainer","_internalRoot","current","$recoilDebugStates","isArray","snapObj","hasOwnProperty","from","snapshotIndex","now","Date","getTime"],"mappings":"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","sourcesContent":["import React, {useState, useEffect} from 'react';\nimport {\n  useRecoilTransactionObserver_UNSTABLE,\n  useRecoilSnapshot,\n  useGotoRecoilSnapshot,\n} from 'recoil';\nimport {formatFiberNodes} from './formatFiberNodes';\n// grabs isPersistedState from sessionStorage\nlet isPersistedState = sessionStorage.getItem('isPersistedState');\n// isRestored state disables snapshots from being recorded\nlet isRestoredState = false;\n// set default throttle to 70, throttle timer changes with every snapshot\nlet throttleTimer = 0;\nlet throttleLimit = 70;\n// persistedSnapshots initially null\n// let persistedSnapshots = null;\nexport default function RecoilizeDebugger(props) {\n  // We should ask for Array of atoms and selectors.\n  // Captures all atoms that were defined to get the initial state\n  // Check if a root was passed to props.\n  if (props.root) {\n    const {root} = props;\n  } else {\n    const root = document.getElementById('root');\n  }\n  const snapshot = useRecoilSnapshot();\n  // getNodes_UNSTABLE will return an iterable that contains atom and selector objects.\n  const nodes = [...snapshot.getNodes_UNSTABLE()];\n  // Local state of all previous snapshots to use for time traveling when requested by dev tools.\n  const [snapshots, setSnapshots] = useState([snapshot]);\n  // const [isRestoredState, setRestoredState] = useState(false);\n  const gotoSnapshot = useGotoRecoilSnapshot();\n  const filteredSnapshot = {};\n  /*\n  A nodeDeps object is constructed using getDeps_UNSTABLE. \n  This object will then be used to construct a nodeSubscriptions object. \n  After continuous testing, getSubscriptions_UNSTABLE was deemed too unreliable. \n  */\n  const nodeDeps = {};\n  const nodeSubscriptions = {};\n  nodes.forEach((node) => {\n    const getDeps = [...snapshot.getDeps_UNSTABLE(node)];\n    nodeDeps[node.key] = getDeps.map(dep => dep.key);\n  });\n  for (let key in nodeDeps) {\n    nodeDeps[key].forEach(node => {\n      if(nodeSubscriptions[node]){\n        nodeSubscriptions[node].push(key);\n      } else {\n        nodeSubscriptions[node] = [key];\n      }\n    });\n  };\n  // Traverse all atoms and selector state nodes and get value\n  nodes.forEach((node, index) => {\n    const type = node.__proto__.constructor.name;\n    const contents = snapshot.getLoadable(node).contents;\n    // Construct node data structure for dev tool to consume\n    filteredSnapshot[node.key] = {\n      type,\n      contents,\n      nodeDeps: nodeDeps[node.key],\n      nodeToNodeSubscriptions: nodeSubscriptions[node.key] ? nodeSubscriptions[node.key] : []\n    };\n  });\n  // React lifecycle hook on re-render\n  useEffect(() => {\n    // Window listener for messages from dev tool UI & background.js\n    window.addEventListener('message', onMessageReceived);\n    if (!isRestoredState) {\n      const devToolData = createDevToolDataObject(filteredSnapshot);\n      // Post message to content script on every re-render of the developers application only if content script has started\n      sendWindowMessage('recordSnapshot', devToolData);\n    } else {\n      isRestoredState = false;\n    }\n    // Clears the window event listener.\n    return () => window.removeEventListener('message', onMessageReceived);\n  });\n  // Listener callback for messages sent to windowf\n  const onMessageReceived = msg => {\n    // Add other actions from dev tool here\n    switch (msg.data.action) {\n      // Checks to see if content script has started before sending initial snapshot\n      case 'contentScriptStarted':\n        if (isPersistedState === 'false' || isPersistedState === null) {\n          const initialFilteredSnapshot = formatAtomSelectorRelationship(\n            filteredSnapshot,\n          );\n          const devToolData = createDevToolDataObject(initialFilteredSnapshot);\n          sendWindowMessage('moduleInitialized', devToolData);\n        } else {\n          setProperIndexForPersistedState();\n          sendWindowMessage('persistSnapshots', null);\n        }\n        break;\n      // Listens for a request from dev tool to time travel to previous state of the app.\n      case 'snapshotTimeTravel':\n        timeTravelToSnapshot(msg);\n        break;\n      case 'persistState':\n        switchPersistMode();\n        break;\n      // Implementing the throttle change\n      case 'throttleEdit':\n        throttleLimit = parseInt(msg.data.payload.value);\n        break;\n      default:\n        break;\n    }\n  };\n  // assigns or switches isPersistedState in sessionStorage\n  const switchPersistMode = () => {\n    if (isPersistedState === 'false' || isPersistedState === null) {\n      // switch isPersistedState in sessionStorage to true\n      sessionStorage.setItem('isPersistedState', true);\n      // stores the length of current list of snapshots in sessionStorage\n      sessionStorage.setItem('persistedSnapshots', snapshots.length);\n    } else {\n      // switch isPersistedState in sessionStorage to false\n      sessionStorage.setItem('isPersistedState', false);\n    }\n  };\n  // function retreives length and fills snapshot array\n  const setProperIndexForPersistedState = () => {\n    const retreived = sessionStorage.getItem('persistedSnapshots');\n    const snapshotsArray = new Array(Number(retreived) + 1).fill({});\n    setSnapshots(snapshotsArray);\n  };\n  // Sends window an action and payload message.\n  const sendWindowMessage = (action, payload) => {\n    window.postMessage(\n      {\n        action,\n        payload,\n      },\n      '*',\n    );\n  };\n  const createDevToolDataObject = filteredSnapshot => {\n    return {\n      filteredSnapshot: filteredSnapshot,\n      componentAtomTree: formatFiberNodes(\n        root._reactRootContainer._internalRoot.current,\n      ),\n    };\n  };\n  const formatAtomSelectorRelationship = filteredSnapshot => {\n    if (\n      window.$recoilDebugStates &&\n      Array.isArray(window.$recoilDebugStates) &&\n      window.$recoilDebugStates.length\n    ) {\n      let snapObj =\n        window.$recoilDebugStates[window.$recoilDebugStates.length - 1];\n      if (snapObj.hasOwnProperty('nodeDeps')) {\n        for (let [key, value] of snapObj.nodeDeps) {\n          filteredSnapshot[key].nodeDeps = Array.from(value);\n        }\n      }\n      if (snapObj.hasOwnProperty('nodeToNodeSubscriptions')) {\n        for (let [key, value] of snapObj.nodeToNodeSubscriptions) {\n          filteredSnapshot[key].nodeToNodeSubscriptions = Array.from(value);\n        }\n      }\n    }\n    return filteredSnapshot;\n  };\n  // FOR TIME TRAVEL: time travels to a given snapshot, re renders application.\n  const timeTravelToSnapshot = async msg => {\n    // await setRestoredState(true);\n    // await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n    // await setRestoredState(false);\n    isRestoredState = true;\n    await gotoSnapshot(snapshots[msg.data.payload.snapshotIndex]);\n  };\n  // FOR TIME TRAVEL: Recoil hook to fire a callback on every atom/selector change -- research Throttle\n  useRecoilTransactionObserver_UNSTABLE(({snapshot}) => {\n    const now = new Date().getTime();\n    if (now - throttleTimer < throttleLimit) {\n      isRestoredState = true;\n    } else {\n      throttleTimer = now;\n    }\n    if (!isRestoredState) {\n      setSnapshots([...snapshots, snapshot]);\n    }\n  });\n  return null;\n}"]},"metadata":{},"sourceType":"module"}